name: Deploy Zero Trust Lab

on:
  workflow_dispatch:
    inputs:
      deployment_type:
        description: 'Deployment Type'
        required: true
        type: choice
        options:
          - cloud-only-basic
          - cloud-only-full
          - azure-ad-only
          - managed-identity-only
          - storage-only
        default: 'cloud-only-full'
      user_count:
        description: 'Number of Azure AD users'
        required: false
        default: '100'
      app_count:
        description: 'Number of Azure AD applications'
        required: false
        default: '7'
      upn_suffix:
        description: 'UPN suffix (e.g., company.com)'
        required: true
      enable_privileged_roles:
        description: 'Enable privileged role assignments (Global Admin, etc.)'
        required: false
        type: boolean
        default: true
      deployment_method:
        description: 'Azure AD Deployment Method'
        required: false
        type: choice
        options:
          - Terraform
          - GraphAPI
        default: 'Terraform'
      lab_name:
        description: 'Lab name for resources'
        required: false
        default: 'ZeroTrustLab'
      azure_location:
        description: 'Azure region'
        required: false
        default: 'eastus'
        type: choice
        options:
          - eastus
          - westus
          - centralus
          - northeurope
          - westeurope
          - southeastasia
      auto_destroy_hours:
        description: 'Auto-destroy after hours (0 = manual)'
        required: false
        default: '0'

env:
  ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
  ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  TF_VERSION: '1.5.0'
  PYTHON_VERSION: '3.8'
  TF_LOG: INFO
  TF_PLUGIN_CACHE_DIR: ${{ github.workspace }}/.terraform.d/plugin-cache

jobs:
  deploy:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    
    outputs:
      deployment_id: ${{ steps.set_outputs.outputs.deployment_id }}
      resource_groups: ${{ steps.set_outputs.outputs.resource_groups }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          lfs: true
      
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install faker
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false
      
      - name: Prepare Terraform plugin cache
        run: |
          mkdir -p "$TF_PLUGIN_CACHE_DIR"
      
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ secrets.AZURE_CLIENT_ID }}",
              "clientSecret": "${{ secrets.AZURE_CLIENT_SECRET }}",
              "subscriptionId": "${{ secrets.AZURE_SUBSCRIPTION_ID }}",
              "tenantId": "${{ secrets.AZURE_TENANT_ID }}"
            }
      
      - name: Generate Azure AD Configuration
        if: |
          inputs.deployment_type == 'cloud-only-basic' || 
          inputs.deployment_type == 'cloud-only-full' || 
          inputs.deployment_type == 'azure-ad-only'
        working-directory: generators/azure_ad
        run: |
          PRIV_FLAGS=""
          if [ "${{ inputs.enable_privileged_roles }}" == "true" ]; then
            PRIV_FLAGS="-aa -pra -ga"
          fi
          
          python3 azure_ad.py \
            -c ${{ inputs.user_count }} \
            -u ${{ inputs.upn_suffix }} \
            --apps ${{ inputs.app_count }} \
            --groups 4 \
            $PRIV_FLAGS
      
      - name: Terraform Init - Azure AD
        if: |
          (inputs.deployment_type == 'cloud-only-basic' || 
           inputs.deployment_type == 'cloud-only-full' || 
           inputs.deployment_type == 'azure-ad-only') &&
          inputs.deployment_method == 'Terraform'
        working-directory: generators/azure_ad
        run: terraform init
      
      - name: Terraform Plan - Azure AD
        if: |
          (inputs.deployment_type == 'cloud-only-basic' || 
           inputs.deployment_type == 'cloud-only-full' || 
           inputs.deployment_type == 'azure-ad-only') &&
          inputs.deployment_method == 'Terraform'
        working-directory: generators/azure_ad
        run: terraform plan -input=false -no-color -out=azure_ad.tfplan
      
      - name: Terraform Apply - Azure AD
        if: |
          (inputs.deployment_type == 'cloud-only-basic' || 
           inputs.deployment_type == 'cloud-only-full' || 
           inputs.deployment_type == 'azure-ad-only') &&
          inputs.deployment_method == 'Terraform'
        working-directory: generators/azure_ad
        run: |
          # Apply with retries to handle transient Azure AD issues
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Attempt $((RETRY_COUNT + 1)) of $MAX_RETRIES..."
            
            if terraform apply -auto-approve -parallelism=1 -input=false -lock-timeout=30m -no-color azure_ad.tfplan; then
              echo "Terraform apply succeeded!"
              exit 0
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Apply failed. Waiting 60 seconds before retry..."
                sleep 60
                # Refresh the plan for retry
                terraform plan -input=false -no-color -out=azure_ad.tfplan
              else
                echo "All retry attempts exhausted."
                exit 1
              fi
            fi
          done

      - name: Graph API Deployment - Azure AD
        if: |
          (inputs.deployment_type == 'cloud-only-basic' || 
           inputs.deployment_type == 'cloud-only-full' || 
           inputs.deployment_type == 'azure-ad-only') &&
          inputs.deployment_method == 'GraphAPI'
        working-directory: generators/azure_ad
        shell: pwsh
        run: |
          $password = -join ((65..90) + (97..122) + (48..57) | Get-Random -Count 12 | ForEach-Object { [char]$_ }) + "1!Aa"
          Write-Host "Generated password for Graph API users: $password"
          ./deploy-graph-users.ps1 -CsvFile "./azure_users.csv" -Password $password
      
      - name: Get Public IP
        id: get_ip
        run: |
          IP=$(curl -s https://api.ipify.org)
          echo "public_ip=$IP" >> $GITHUB_OUTPUT
          echo "Runner Public IP: $IP"

      - name: Generate Terraform - Storage
        if: |
          inputs.deployment_type == 'cloud-only-full' || 
          inputs.deployment_type == 'storage-only'
        working-directory: generators/storage
        run: |
          python3 storage.py \
            -n ${{ inputs.lab_name }} \
            -l ${{ inputs.azure_location }} \
            -ip ${{ steps.get_ip.outputs.public_ip }}
      
      - name: Terraform Init - Storage
        if: |
          inputs.deployment_type == 'cloud-only-full' || 
          inputs.deployment_type == 'storage-only'
        working-directory: generators/storage
        run: terraform init
      
      - name: Import Resource Group (Storage)
        if: |
          inputs.deployment_type == 'cloud-only-full' || 
          inputs.deployment_type == 'storage-only'
        working-directory: generators/storage
        run: |
          # The name logic needs to match python script default or input
          # In the python script: default_name = args.name (if provided) else "purplecloud"
          # Then friendly_name = "PURPLECLOUD-FRIENDLY" replaced by default_name
          # Resource group name is friendly_name
          
          RG_NAME="${{ inputs.lab_name }}"
          if [ -z "$RG_NAME" ]; then
            RG_NAME="purplecloud"
          fi
          
          echo "Checking if Resource Group '$RG_NAME' exists..."
          if [ $(az group exists --name "$RG_NAME") = "true" ]; then
            echo "Resource Group '$RG_NAME' exists. Importing..."
            terraform import azurerm_resource_group.pc_storage /subscriptions/$ARM_SUBSCRIPTION_ID/resourceGroups/$RG_NAME || echo "Import failed (maybe already imported)"
          else
            echo "Resource Group '$RG_NAME' does not exist. Terraform will create it."
          fi

      - name: Purge Soft-Deleted Key Vault
        if: |
          inputs.deployment_type == 'cloud-only-full' || 
          inputs.deployment_type == 'storage-only'
        run: |
          KV_NAME="${{ inputs.lab_name }}"
          # Key Vault name must match what is generated in storage.py (which defaults to lab_name/args.name)
          
          echo "Checking for soft-deleted Key Vault '$KV_NAME'..."
          DELETED_KV=$(az keyvault list-deleted --query "[?name=='$KV_NAME'].name" -o tsv)
          
          if [ -n "$DELETED_KV" ]; then
            echo "Found soft-deleted Key Vault '$DELETED_KV'. Purging..."
            az keyvault purge --name "$DELETED_KV" --location ${{ inputs.azure_location }} --no-wait
            echo "Purge command sent. Waiting 60 seconds for cleanup..."
            sleep 60
          else
            echo "No soft-deleted Key Vault found with name '$KV_NAME'."
          fi

      - name: Terraform Plan - Storage
        if: |
          inputs.deployment_type == 'cloud-only-full' || 
          inputs.deployment_type == 'storage-only'
        working-directory: generators/storage
        run: terraform plan -out=storage.tfplan
      
      - name: Terraform Apply - Storage
        if: |
          inputs.deployment_type == 'cloud-only-full' || 
          inputs.deployment_type == 'storage-only'
        working-directory: generators/storage
        run: terraform apply -auto-approve storage.tfplan
      
      - name: Generate Terraform - Managed Identity
        if: |
          inputs.deployment_type == 'cloud-only-full' || 
          inputs.deployment_type == 'managed-identity-only'
        working-directory: generators/managed_identity
        run: |
          EXISTING_RG_FLAG=""
          if [ "${{ inputs.deployment_type }}" == "cloud-only-full" ]; then
            EXISTING_RG_FLAG="-e"
          fi
          
          python3 managed_identity.py \
            -u ${{ inputs.upn_suffix }} \
            -ua owner \
            -sa \
            -n ${{ inputs.lab_name }} \
            -l ${{ inputs.azure_location }} \
            $EXISTING_RG_FLAG
      
      - name: Terraform Init - Managed Identity
        if: |
          inputs.deployment_type == 'cloud-only-full' || 
          inputs.deployment_type == 'managed-identity-only'
        working-directory: generators/managed_identity
        run: terraform init
      
      - name: Import Resource Group (Managed Identity)
        if: |
          inputs.deployment_type == 'managed-identity-only' &&
          inputs.deployment_type != 'cloud-only-full'
        working-directory: generators/managed_identity
        run: |
            # Logic similar to storage, check if RG exists and import.
            # However, managed_identity uses a random suffix for RG defined in python script?
            # Looking at managed_identity.tf template in python script:
            # resource "azurerm_resource_group" "pcmi" { name = local.mi_friendly_name ... }
            # local.mi_friendly_name = "PURPLECLOUD-FRIENDLY" -> replaced by args.name or default default_name
            # default_name = "purpleidentity${random_string.misuffix.id}" if name not passed.
            # If name IS passed (-n), then RG name is that name.
            
            # The workflow passes -n ${{ inputs.lab_name }} for cloud-only-full, but 
            # for managed-identity-only checks?
            # Wait, the workflow step "Generate Terraform - Managed Identity" passes:
            # -n ${{ inputs.lab_name }}
            
            RG_NAME="${{ inputs.lab_name }}"
            
            echo "Checking if Resource Group '$RG_NAME' exists..."
            if [ $(az group exists --name "$RG_NAME") = "true" ]; then
              echo "Resource Group '$RG_NAME' exists. Importing..."
              terraform import azurerm_resource_group.pcmi /subscriptions/$ARM_SUBSCRIPTION_ID/resourceGroups/$RG_NAME || echo "Import failed (maybe already imported)"
            else
              echo "Resource Group '$RG_NAME' does not exist. Terraform will create it."
            fi

      - name: Terraform Plan - Managed Identity
        if: |
          inputs.deployment_type == 'cloud-only-full' || 
          inputs.deployment_type == 'managed-identity-only'
        working-directory: generators/managed_identity
        run: terraform plan -out=managed_identity.tfplan
      
      - name: Terraform Apply - Managed Identity
        if: |
          inputs.deployment_type == 'cloud-only-full' || 
          inputs.deployment_type == 'managed-identity-only'
        working-directory: generators/managed_identity
        run: terraform apply -auto-approve managed_identity.tfplan
      
      - name: Capture Resource Group Names
        id: capture_rgs
        run: |
          echo "Capturing created resource groups..."
          RGS=$(az group list --query "[?starts_with(name, 'PurpleCloud') || contains(name, '${{ inputs.lab_name }}')].name" -o tsv | tr '\n' ',' | sed 's/,$//')
          echo "resource_groups=$RGS" >> $GITHUB_OUTPUT
          echo "Found resource groups: $RGS"
      
      - name: Save Terraform State
        uses: actions/upload-artifact@v4
        with:
          name: terraform-state-${{ github.run_number }}
          path: |
            generators/**/terraform.tfstate
            generators/**/terraform.tfstate.backup
            generators/**/*.tf
            generators/**/*.csv
            generators/**/.terraform.lock.hcl
          retention-days: 30
      
      - name: Set Outputs
        id: set_outputs
        run: |
          DEPLOYMENT_ID="deployment-${{ github.run_number }}-$(date +%s)"
          echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          echo "resource_groups=${{ steps.capture_rgs.outputs.resource_groups }}" >> $GITHUB_OUTPUT
      
      - name: Generate Deployment Summary
        run: |
          echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Configuration" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployment Type**: ${{ inputs.deployment_type }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployment Method**: ${{ inputs.deployment_method }}" >> $GITHUB_STEP_SUMMARY
          echo "- **UPN Suffix**: ${{ inputs.upn_suffix }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Lab Name**: ${{ inputs.lab_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Azure Location**: ${{ inputs.azure_location }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Users Created**: ${{ inputs.user_count }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Apps Created**: ${{ inputs.app_count }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Privileged Roles**: ${{ inputs.enable_privileged_roles }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Resources" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployment ID**: ${{ steps.set_outputs.outputs.deployment_id }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Resource Groups**: ${{ steps.capture_rgs.outputs.resource_groups }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Timestamp**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Review deployed resources in Azure Portal" >> $GITHUB_STEP_SUMMARY
          echo "2. Run your Zero Trust audit scripts" >> $GITHUB_STEP_SUMMARY
          echo "3. Clean up using the 'Cleanup Zero Trust Lab' workflow when done" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ inputs.auto_destroy_hours }}" != "0" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "â° **Auto-destroy scheduled in ${{ inputs.auto_destroy_hours }} hours**" >> $GITHUB_STEP_SUMMARY
          fi
      
      - name: Post Deployment Outputs
        run: |
          echo "=================================="
          echo "Deployment Complete!"
          echo "=================================="
          echo "Deployment ID: ${{ steps.set_outputs.outputs.deployment_id }}"
          echo "Resource Groups: ${{ steps.capture_rgs.outputs.resource_groups }}"
          echo ""
          echo "Access your resources at:"
          echo "https://portal.azure.com/#blade/HubsExtension/BrowseResourceGroups"
  
  schedule-cleanup:
    name: Schedule Auto-Cleanup
    runs-on: ubuntu-latest
    needs: deploy
    if: inputs.auto_destroy_hours != '0'
    
    steps:
      - name: Wait for scheduled cleanup time
        run: |
          SECONDS=$((60 * 60 * ${{ inputs.auto_destroy_hours }}))
          echo "Waiting ${{ inputs.auto_destroy_hours }} hours before triggering cleanup..."
          sleep $SECONDS
      
      - name: Trigger Cleanup Workflow
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'cleanup-resources.yml',
              ref: 'main',
              inputs: {
                deployment_type: '${{ inputs.deployment_type }}',
                confirm_destroy: 'AUTO-DESTROY',
                delete_state: 'true',
                deployment_id: '${{ needs.deploy.outputs.deployment_id }}'
              }
            });
            
            console.log('Cleanup workflow triggered after ${{ inputs.auto_destroy_hours }} hours');
